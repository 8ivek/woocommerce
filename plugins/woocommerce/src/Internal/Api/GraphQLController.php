<?php

namespace Automattic\WooCommerce\Internal\Api;

use GraphQL\Error\Error;
use GraphQL\Error\FormattedError;
use GraphQL\GraphQL;
use GraphQL\Type\Schema;
use GraphQL\Error\ClientAware;
use GraphQL\Error\DebugFlag as Debug;
use \GraphQL\Type\Definition\ResolveInfo;

use Automattic\WooCommerce\Internal\Api\Autogenerated\RootQueryType; // !!!AutogeneratedMock
use Automattic\WooCommerce\Internal\Api\Autogenerated\RootMutationType; // !!!AutogeneratedMock

/**
 * Main controller and utility methods holder for the WooCommerce GraphQL engine.
 */
class GraphQLController {

	/**
	 * Cache for already resolved GraphQL types.
	 *
	 * This is needed because the GraphQL engine requires a single instance of each
	 * object to be returned every time (and incidentally, allows to save some memory).
	 *
	 * These classes are resolved and cached manually, instead of via the dependency injection engine,
	 * because they are internal classes used exclusively by the GraphQL engine and are of no use
	 * for the WooCommerce code itself.
	 *
	 * @var array
	 */
	private static $types_cache = array();

	/**
	 * Names of the GraphQL-friendly primitive types.
	 *
	 * @var string[]
	 */
	private static $primitive_type_names = array( 'int', 'string', 'boolean', 'float' );

	/**
	 * Initialize the controller.
	 */
	public static function initialize(): void {
		\GraphQL\Error\FormattedError::setInternalErrorMessage( __( 'Unexpected error', 'woocommerce' ) );

		add_action(
			'rest_api_init',
			function () {
				register_rest_route(
					'wc/v4',
					'/graphql',
					array(
						'methods'             => 'POST',
						'callback'            => fn( $request ) => self::handle_request( $request ),
						'permission_callback' => '__return_true',
					)
				);
			}
		);
	}

	/**
	 * Handle a request for the GraphQL endpoint.
	 *
	 * A POST request is expected with a body encoded in JSON, having a "query" key containing the
	 * query or mutation in GraphQL syntax, and an optional "variables" key which is a regular JSON object.
	 *
	 * @param \WP_REST_Request $request Incoming request.
	 * @return array|\WP_Error Response.
	 */
	private static function handle_request( \WP_REST_Request $request ) {
		try {
			$input = json_decode( $request->get_body(), true );
			if ( is_null( $input ) ) {
				// Should never happen since WP REST engine already catches invalid JSON errors, but it doesn't hurt to check it anyway.
				return self::error_response(
					/* translators: %s = error message from the JSON decoder */
					sprintf( __( 'Invalid input JSON: %s', 'woocommerce' ), json_last_error_msg() ),
					'rest_invalid_json',
					400
				);
			}
			if ( ! isset( $input['query'] ) ) {
				return self::error_response( __( "Invalid input JSON: no 'query' key present", 'woocommerce' ), 'rest_invalid_json', 400 );
			}

			$query           = $input['query'];
			$variable_values = $input['variables'] ?? null;

			$schema = new Schema(
				array(
					'query'      => new RootQueryType(),
					'mutation'   => new RootMutationType(),
					'typeLoader' => function( $name ) {
						return self::resolve_type( $name );
					},
				)
			);

			$result =
				GraphQL::executeQuery( $schema, $query, null, null, $variable_values )
				->setErrorFormatter( fn ( Error $error): array => self::format_error( $error ) );
			return $result->toArray( self::get_debug_config() );
		} catch ( \Exception $e ) {
			return self::error_response( $e, 'internal_server_error', 500 );
		}
	}

	/**
	 * Return an error response, verbose or not depending on the current debug configuration.
	 *
	 * @param \Exception $error The error thrown by GraphQL::executeQuery.
	 * @param string     $code Error code to use.
	 * @param int        $status_code HTTP status code to return.
	 * @return \WP_Error Error to be returned to the WordPress' JSON API engine.
	 */
	private static function error_response( $error, $code, $status_code ) {
		if ( is_string( $error ) ) {
			return new \WP_Error( $code, $error, array( 'status' => $status_code ) );
		} elseif ( self::get_debug_config() ) {
			return new \WP_Error(
				$code,
				$error->getMessage(),
				array(
					'status' => $status_code,
					'trace'  => $error->getTrace(),
				)
			);
		} else {
			return new \WP_Error( $code, 'Internal server error', array( 'status' => $status_code ) );
		}
	}

	/**
	 * Get debug flags for GraphQL::executeQuery()->toArray.
	 *
	 * When debug flags are returned error output will always include the exception error message
	 * and the output will also include a full stack trace.
	 *
	 * Debug flags are returned when "?verbose_errors" is added to the query string AND
	 * either the user is in the "administrator" role OR the WP_DEBUG constant is set.
	 *
	 * @return false|int Debug flags or false.
	 */
	private static function get_debug_config() {
		// phpcs:ignore WordPress.Security.NonceVerification.Recommended
		if ( ! isset( $_GET['verbose_errors'] ) ) {
			return false;
		}

		if ( wc_current_user_has_role( 'administrator' ) || ( defined( 'WP_DEBUG' ) && WP_DEBUG ) ) {
			return Debug::INCLUDE_DEBUG_MESSAGE | Debug::INCLUDE_TRACE;
		}

		return false;
	}

	/**
	 * Error formatter to be used by the GraphQL engine.
	 * It will cause the actual error message to be included in the output (even in not-verbose responses)
	 * if the error is an instance of InvalidArgumentException or the exception class has an
	 * 'is_client_aware' method that returns true.
	 *
	 * @param Error $error The error generated by the GraphQL engine.
	 * @return array The formatted error.
	 */
	private static function format_error( Error $error ) {
		$result           = FormattedError::createFromException( $error );
		$actual_exception = $error->getPrevious();
		if ( ! $actual_exception ) {
			return $result;
		}

		if ( ( $actual_exception instanceof \InvalidArgumentException ) || ( method_exists( $actual_exception, 'is_client_aware' ) && $actual_exception->is_client_aware() ) ) {
			$result['message'] = $actual_exception->getMessage();
		}

		return $result;
	}

	/**
	 * Type resolver used by the GraphQL engine and by the REST API v4 controllers,
	 * it's used to resolve both GraphQL types and API classes.
	 * See the comment in the $types_cache property.
	 *
	 * @param string $name Name of the GraphQL type to resolve.
	 * @return object An instance of the resolved type.
	 * @throws \Exception The supplied name is not a known GraphQL class.
	 */
	public static function resolve_type( $name ): object {
		if ( str_contains( $name, '\\' ) ) {
			$name = substr( strrchr( $name, '\\' ), 1 );
		}

		if ( in_array( $name, self::$primitive_type_names, true ) ) {
			return \GraphQL\Type\Definition\Type::$name();
		}

		$type_class_name = 'Automattic\\WooCommerce\\Internal\\Api\\Autogenerated\\GraphQLTypes\\' . $name . 'Type'; // !!!AutogeneratedMock
		$instance        = self::$types_cache[ $type_class_name ] ?? null;
		if ( ! is_null( $instance ) ) {
			return $instance;
		}

		$api_class_name = 'Automattic\\WooCommerce\\Api\\' . $name;
		$container      = wc_get_container();
		if ( $container->has( $api_class_name ) ) {
			return $container->get( $api_class_name );
		}

		if ( class_exists( $type_class_name ) ) {
			$instance                              = new $type_class_name();
			self::$types_cache[ $type_class_name ] = $instance;
			return $instance;
		}

		throw new \Exception( "There's no way to resolve the type '" . $name . "'." );
	}

	/**
	 * Compose a fields info object suitable for $_fields_info arguments in API class methods.
	 *
	 * The resulting array will have one key per requested field, being the value 'true' for scalar fields,
	 * or another array with the same formatting for fields that are of object type.
	 *
	 * Although not yet supported by the API builder, requested field arguments will go into the resulting array too,
	 * in special fields named '_args'.
	 *
	 * @param ResolveInfo $info Request information provided by the GraphQL engine.
	 * @return array Array with information about the requested fields.
	 */
	public static function get_fields_info( ResolveInfo $info ): array {
		return self::get_fields_info_core( $info->lookAhead()->queryPlan() );
	}

	/**
	 * Core get fields info method, invoked by get_fields_info and by itself recursively.
	 *
	 * @param array $fields The current level of requested fields.
	 * @return array Array with information about the requested fields.
	 */
	private static function get_fields_info_core( array $fields ): array {
		$result = array();

		foreach ( $fields as $key => $value ) {
			if ( empty( $value['fields'] ) && empty( $value['args'] ) ) {
				$result[ $key ] = true;
				continue;
			}

			if ( ! empty( $value['args'] ) ) {
				$result[ $key ]['_args'] = $value['args'];
			}

			if ( ! empty( $value['fields'] ) ) {
				$result[ $key ] = array_merge( $result[ $key ] ?? array(), self::get_fields_info_core( $value['fields'] ) );
			}
		}

		return $result;
	}

	/**
	 * Generate a GraphQL input type from an array of properties received in the request.
	 *
	 * This method will be used by default to convert input arrays to input objects,
	 * but as an alternative, input types can define a "public static function parse(array $values)" method
	 * to perform the object generation themselves.
	 *
	 * @param string $type_name The name of the required input type.
	 * @param array  $input_values The input values received in the request.
	 * @return mixed The generated input type.
	 */
	public static function parse_input_value( string $type_name, array $input_values ) {
		$class_name = 'Automattic\\WooCommerce\\Api\\InputTypes\\' . $type_name;
		$instance   = new $class_name();
		$properties = get_class_vars( $class_name );
		foreach ( array_keys( $properties ) as $property ) {
			$instance->{$property} = $input_values[ $property ] ?? null;
		}
		return $instance;
	}
}
