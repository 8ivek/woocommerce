<?php

namespace Automattic\WooCommerce\Internal\Api\DesignTime\Scripts;

use ReflectionClass;
use ReflectionNamedType;
use ReflectionMethod;
use ReflectionProperty;

// phpcs:disable WordPress.WP.AlternativeFunctions, WordPress.Security.EscapeOutput.OutputNotEscaped, WordPress.PHP.YodaConditions.NotYoda

/**
 * The WooCommerce API builder class.
 * The entry point is the "run" method.
 */
class ApiBuilder {
	private static array $source_files       = array();
	private static string $base_source_dir   = __DIR__ . '/../../../../Api';
	private static string $base_internal_dir = __DIR__ . '/../../../../Internal/Api';

	private static string $base_source_namespace   = 'Automattic\\WooCommerce\\Api\\';
	private static string $base_internal_namespace = 'Automattic\\WooCommerce\\Internal\\Api\\';

	private static string $base_autogenerated_namespace = 'Automattic\\WooCommerce\\Internal\\Api\\Autogenerated\\';

	private static string $autogenerated_dir;
	private static string $templates_dir;
	private static string $base_docs_dir;

	private static array $reflection_classes_cache = array();

	private static array $warnings;
	private static array $errors;

	private static array $used_graphql_query_names = array();

	private static array $used_rest_query_names = array();

	private static array $allowed_primitive_types = array( 'int', 'string', 'float', 'bool', 'boolean', 'array' );

	private static array $primitive_type_to_rest_type = array(
		'int'     => 'integer',
		'string'  => 'string',
		'float'   => 'number',
		'bool'    => 'boolean',
		'boolean' => 'boolean',
		'array'   => 'array',
	);

	private static array $query_methods;

	private static array $mutation_methods;

	private static array $api_dirs_and_names = array(
		'Enums'       => 'Enum Types',
		'InputTypes'  => 'Input Types',
		'Interfaces'  => 'Interface Types',
		'ObjectTypes' => 'Object Types',
		'Queries'     => 'Queries',
		'Mutations'   => 'Mutations',
	);

	/**
	 * Build the code for the WooCommerce GraphQL and REST v4 APIs in the src/Internal/Api/Autogenerated directory.
	 * If there are errors it prints them and finishes with an exit code of 1.
	 */
	public static function run(): void {
		if ( version_compare( phpversion(), '8', '<' ) ) {
			echo "*** This script requires PHP 8.0 or newer.\n";
			exit( 1 );
		}

		echo "Generating code...\n";

		spl_autoload_register( fn( $class_name ) => self::load_class( $class_name ), true, true );

		self::$warnings = array();
		self::$errors   = array();

		self::initialize_class_properties();
		self::initialize_use_statements_injector();
		self::find_source_files();
		self::init_autogenerated_dir();
		self::generate_api_classes_service_provider_file();
		self::generate_graphql_types();
		self::generate_graphql_query_classes( false );
		self::generate_graphql_query_classes( true );
		self::generate_rest_controller_classes();

		if ( empty( self::$errors ) ) {
			$date = gmdate( 'Y-m-d H:i:s' );
			file_put_contents( self::$autogenerated_dir . '/api_generation_date.txt', $date );

			if ( getenv( 'SKIP_DOCS_GENERATION' ) === false ) {
				self::generate_documentation();
				file_put_contents( self::$base_docs_dir . '/api_docs_generation_date.txt', $date );
			}
		}

		$error_code = self::show_result();
		exit( $error_code );
	}

	/**
	 * Show the result of the script run (success, warnings list or errors list).
	 *
	 * @return int Exit code for the script, 0 on success or if there are only warnings, 1 if there are errors.
	 */
	private static function show_result(): int {
		if ( ! empty( self::$errors ) ) {
			echo "Process failed, errors found:\n\n";
			foreach ( self::$errors as $error ) {
				echo $error;
				echo "\n\n";
			}
			return 1;
		}

		if ( ! empty( self::$warnings ) ) {
			echo "Process finished with warnings:\n\n";
			foreach ( self::$warnings as $warning ) {
				echo $warning;
				echo "\n\n";
			}
		} else {
			echo "Success!\n";
		}

		return 0;
	}

	/**
	 * Initialize the internal class properties to their initial values.
	 */
	private static function initialize_class_properties(): void {
		self::$base_source_dir   = realpath( self::$base_source_dir );
		self::$base_internal_dir = realpath( self::$base_internal_dir );
		self::$autogenerated_dir = self::$base_internal_dir . '/Autogenerated';
		self::$templates_dir     = self::$base_internal_dir . '/DesignTime/Templates';

		self::$reflection_classes_cache = array();
		self::$used_graphql_query_names = array();
		self::$used_rest_query_names    = array();
		self::$query_methods            = array();
		self::$mutation_methods         = array();
	}

	/**
	 * Initialize the "use" statements injector AKA The (adapted) Code Hacker.
	 * See UseStatemensInjector.php in the same directory of this script.
	 */
	private static function initialize_use_statements_injector(): void {
		$attribute_class_files = glob( self::$base_internal_dir . '/DesignTime/Attributes/*' );
		$attribute_class_names = array_map( fn( $file_name ) => self::class_name_from_file_name( $file_name ), $attribute_class_files );
		UseStatementsInjector::register_classes_to_inject_with_use( $attribute_class_names );
		stream_wrapper_unregister( UseStatementsInjector::PROTOCOL );
		stream_wrapper_register( UseStatementsInjector::PROTOCOL, UseStatementsInjector::class );
	}

	/**
	 * Scan the src/Api directory and build a list of the relevant code classes that will be processed.
	 */
	private static function find_source_files(): void {
		$source_dirs = glob( self::$base_source_dir . '/*', GLOB_ONLYDIR );
		foreach ( $source_dirs as $dir ) {
			self::$source_files[ basename( $dir ) ] = self::file_search( $dir );
		}
		self::$source_files['Apis'] = self::file_search( self::$base_source_dir, false );
	}

	/**
	 * Initialize the src/Internal/Api/Autogenerated directory by deleting its previous contents.
	 */
	private static function init_autogenerated_dir(): void {
		if ( is_dir( self::$autogenerated_dir ) ) {
			self::recursive_rmdir( self::$autogenerated_dir, false );
		} else {
			mkdir( self::$autogenerated_dir );
		}
	}

	/**
	 * Generate the ApiClassesServiceProvider.php file.
	 */
	private static function generate_api_classes_service_provider_file(): void {
		$api_classes = array_map( fn( $file_name ) => self::class_name_from_file_name( $file_name ) . '::class', self::$source_files['Apis'] );
		self::generate_file( 'ApiClassesServiceProvider', array( 'CLASS_NAMES' => implode( ",\n\t\t", $api_classes ) ) );
	}

	/**
	 * Generate the GraphQL type files in the src/Internal/Api/Autogenerated/GraphQLTypes directory.
	 */
	private static function generate_graphql_types(): void {
		mkdir( self::$autogenerated_dir . '/GraphQLTypes' );

		foreach ( self::$source_files['Enums'] as $file ) {
			self::generate_graphql_enum_type( self::class_name_from_file_name( $file ) );
		}

		foreach ( self::$source_files['Interfaces'] as $file ) {
			self::generate_graphql_interface_type( self::class_name_from_file_name( $file ) );
		}

		foreach ( self::$source_files['InputTypes'] as $file ) {
			self::generate_graphql_input_type( self::class_name_from_file_name( $file ) );
		}

		foreach ( self::$source_files['ObjectTypes'] as $file ) {
			self::generate_graphql_object_type( self::class_name_from_file_name( $file ) );
		}
	}

	/**
	 * Generate the GraphQL type for an API enum type.
	 *
	 * @param string $class_name Class name of the enum type.
	 */
	private static function generate_graphql_enum_type( string $class_name ): void {
		$reflection_class      = self::get_reflection_object( $class_name );
		$description_attribute = self::get_attribute( $reflection_class, 'Description' );
		$simple_class_name     = self::class_name_without_namespace( $class_name );
		$description           = is_null( $description_attribute ) ? $simple_class_name . ' enum type' : $description_attribute->description;

		$code_parts = array();
		$constants  = $reflection_class->getConstants();
		foreach ( $constants as $constant_name => $constant_value ) {
			$reflection_constant = new \ReflectionClassConstant( $class_name, $constant_name );
			if ( ! $reflection_constant->isPublic() ) {
				self::$warnings[] = "Enum type '$simple_class_name': constant '$constant_name' is not public and will be ignored.";
				continue;
			}
			$code_value           = is_string( $constant_value ) ? self::code_string( $constant_value ) : $constant_value;
			$code_part            = "\t\t\t\t" . self::code_string( $constant_name ) . " => [\n\t\t\t\t\t'value' => " . $code_value . ",\n";
			$constant_description = self::get_attribute( $reflection_constant, 'Description' );
			if ( ! is_null( $constant_description ) ) {
				$code_part .= "\t\t\t\t\t'description' => " . self::translated_code_string( $constant_description->description ) . "\n";
			}
			$code_part   .= "\t\t\t\t]";
			$code_parts[] = $code_part;
		}

		self::generate_file(
			'EnumType',
			array(
				'TYPE_NAME'        => $simple_class_name,
				'QUOTED_TYPE_NAME' => self::code_string( $simple_class_name ),
				'TYPE_DESCRIPTION' => self::translated_code_string( $description ),
				'VALUES'           => implode( ",\n", $code_parts ),
			),
			'GraphQLTypes/' . $simple_class_name . 'Type'
		);
	}

	/**
	 * Generate the GraphQL type for an API interface type.
	 *
	 * @param string $class_name Class name of the interface type.
	 */
	private static function generate_graphql_interface_type( string $class_name ): void {
		$reflection_class      = self::get_reflection_object( $class_name );
		$description_attribute = self::get_attribute( $reflection_class, 'Description' );
		$simple_class_name     = self::class_name_without_namespace( $class_name );
		$description           = is_null( $description_attribute ) ? $simple_class_name . ' interface type' : $description_attribute->description;

		$code_parts = array();
		$properties = $reflection_class->getProperties();
		foreach ( $properties as $property ) {
			$code_part = self::generate_code_for_property_type( $property, $simple_class_name, 'Interface', array( 'Interfaces' ) );
			if ( ! is_null( $code_part ) ) {
				$code_parts[] = $code_part;
			}
		}

		self::generate_file(
			'InterfaceType',
			array(
				'TYPE_NAME'        => $simple_class_name,
				'QUOTED_TYPE_NAME' => self::code_string( $simple_class_name ),
				'TYPE_DESCRIPTION' => self::translated_code_string( $description ),
				'FIELDS'           => implode( ",\n", $code_parts ),
			),
			'GraphQLTypes/' . $simple_class_name . 'Type'
		);
	}

	/**
	 * Generate the GraphQL type for an API input type.
	 *
	 * @param string $class_name Class name of the input type.
	 */
	private static function generate_graphql_input_type( string $class_name ): void {
		$reflection_class      = self::get_reflection_object( $class_name );
		$description_attribute = self::get_attribute( $reflection_class, 'Description' );
		$simple_class_name     = self::class_name_without_namespace( $class_name );
		$description           = is_null( $description_attribute ) ? $simple_class_name . ' input type' : $description_attribute->description;

		$traits               = $reflection_class->getTraits();
		$trait_property_names = self::get_properties_from_traits( $traits );

		$code_parts = array();
		$properties = $reflection_class->getProperties();
		foreach ( $properties as $property ) {
			if ( in_array( $property->getName(), $trait_property_names, true ) ) {
				continue;
			}
			$code_part = self::generate_code_for_property_type( $property, $simple_class_name, 'Input', array( 'Interfaces', 'InputTypes' ) );
			if ( ! is_null( $code_part ) ) {
				$code_parts[] = $code_part;
			}
		}

		$extra_fields_code = array();
		foreach ( $traits as $trait ) {
			$trait_name = $trait->getName();
			if ( ! str_starts_with( $trait_name, self::$base_source_namespace . 'Interfaces\\' ) ) {
				self::$errors[] = "Input type '$simple_class_name' implements trait '$trait_name', which is not in the 'Interfaces' namespace.";
				return;
			}

			$trait_simple_name   = self::class_name_without_namespace( $trait_name );
			$extra_fields_code[] = "\t\t\$fields = array_merge(\$fields, GraphQLController::resolve_type('$trait_simple_name')->get_fields());";
		}

		try {
			$parse_method = $reflection_class->getMethod( 'parse' );
		} catch ( \Exception $e ) {
			// Method doesn't exist.
			$parse_method = null;
		}

		$parse_code = null;
		if ( ! is_null( $parse_method ) && $parse_method->isStatic() && $parse_method->isPublic() ) {
			$parse_args = $parse_method->getParameters();
			if ( count( $parse_args ) === 1 ) {
				$parse_arg_type = current( $parse_args )->getType();
				if ( ! is_null( $parse_arg_type ) && $parse_arg_type->getName() === 'array' ) {
					$parse_code = $class_name . '::parse( $values )';
				}
			}
		}

		if ( is_null( $parse_code ) ) {
			if ( ! is_null( $parse_method ) ) {
				self::$warnings[] = "Input type '$simple_class_name' has a 'parse' method, but it either isn't static, isn't public or doesn't accept one single argument of type 'array'; thus it won't be used for parsing input arrays.";
			}
			$parse_code = "GraphQLController::parse_input_value( '$simple_class_name', \$values )";
		}

		self::generate_file(
			'InputType',
			array(
				'TYPE_NAME'        => $simple_class_name,
				'QUOTED_TYPE_NAME' => self::code_string( $simple_class_name ),
				'PARSE_CODE'       => $parse_code,
				'TYPE_DESCRIPTION' => self::translated_code_string( $description ),
				'FIELDS'           => implode( ",\n", $code_parts ),
				'EXTRA_FIELDS'     => implode( "\n", $extra_fields_code ),
			),
			'GraphQLTypes/' . $simple_class_name . 'Type'
		);
	}

	/**
	 * Generate the GraphQL type for an API object (output) type.
	 *
	 * @param string $class_name Class name of the object type.
	 */
	private static function generate_graphql_object_type( string $class_name ): void {
		$reflection_class      = self::get_reflection_object( $class_name );
		$description_attribute = self::get_attribute( $reflection_class, 'Description' );
		$simple_class_name     = self::class_name_without_namespace( $class_name );
		$description           = is_null( $description_attribute ) ? $simple_class_name . ' object type' : $description_attribute->description;

		$traits               = $reflection_class->getTraits();
		$trait_property_names = self::get_properties_from_traits( $traits );

		$code_parts = array();
		$properties = $reflection_class->getProperties();
		foreach ( $properties as $property ) {
			if ( in_array( $property->getName(), $trait_property_names, true ) ) {
				continue;
			}
			$code_part = self::generate_code_for_property_type( $property, $simple_class_name, 'Object', array( 'Interfaces', 'ObjectTypes' ) );
			if ( ! is_null( $code_part ) ) {
				$code_parts[] = $code_part;
			}
		}

		$interfaces_code   = array();
		$extra_fields_code = array();

		foreach ( $traits as $trait ) {
			$trait_name = $trait->getName();
			if ( ! str_starts_with( $trait_name, self::$base_source_namespace . 'Interfaces\\' ) ) {
				self::$errors[] = "Object type '$simple_class_name' implements trait '$trait_name', which is not in the 'Interfaces' namespace.";
				return;
			}

			$trait_simple_name   = self::class_name_without_namespace( $trait_name );
			$interfaces_code[]   = "\t\t\t\tGraphQLController::resolve_type('$trait_simple_name')";
			$extra_fields_code[] = "\t\t\$fields = array_merge(\$fields, GraphQLController::resolve_type('$trait_simple_name')->get_fields());";
		}

		self::generate_file(
			'ObjectType',
			array(
				'TYPE_NAME'        => $simple_class_name,
				'QUOTED_TYPE_NAME' => self::code_string( $simple_class_name ),
				'INTERFACES'       => implode( ",\n", $interfaces_code ),
				'TYPE_DESCRIPTION' => self::translated_code_string( $description ),
				'FIELDS'           => implode( ",\n", $code_parts ),
				'EXTRA_FIELDS'     => implode( "\n", $extra_fields_code ),
			),
			'GraphQLTypes/' . $simple_class_name . 'Type'
		);
	}

	/**
	 * Get the combined property names from a group of traits.
	 *
	 * @param ReflectionClass[] $traits Array of trait reflection classes.
	 * @return string[] Array of property names.
	 */
	private static function get_properties_from_traits( array $traits ): array {
		$trait_property_names = array();

		foreach ( $traits as $trait ) {
			foreach ( $trait->getProperties() as $property ) {
				$trait_property_names[] = $property->getName();
			}
		}

		return $trait_property_names;
	}

	/**
	 * Generate the PHP code for a class property in the format expected by the underlying GraphQL engine,
	 * taking in account existing enum or array type attributes.
	 *
	 * @param ReflectionProperty $property The reflection object representing the property.
	 * @param string             $simple_class_name The parent class name without the namespace.
	 * @param string             $type_kind 'Input', 'Object' or 'Interface'.
	 * @param array              $allowed_type_namespaces Allowed namespaces (Relative to the src/Api directory) for non-primitive types.
	 * @return string|null The code representation of the type, or null if there's an error.
	 */
	private static function generate_code_for_property_type( ReflectionProperty $property, string $simple_class_name, string $type_kind, array $allowed_type_namespaces ): ?string {
		$property_name = $property->getName();
		if ( ! $property->isPublic() ) {
			self::$warnings[] = "$type_kind type '$simple_class_name': property '$property_name' is not public and will be ignored.";
			return null;
		}

		$property_type       = $property->getType();
		$enum_type_attribute = self::get_attribute( $property, 'EnumType' );
		$array_of_attribute  = self::get_attribute( $property, 'ArrayType' );

		$type_code = self::generate_code_for_type( $property_type, $enum_type_attribute, $array_of_attribute, "$type_kind type '$simple_class_name': property '$property_name'", $allowed_type_namespaces );

		$code_part            = "\t\t\t" . self::code_string( $property_name ) . " => fn() => [\n\t\t\t\t'type' => " . $type_code . ",\n";
		$property_description = self::get_attribute( $property, 'Description' );
		if ( ! is_null( $property_description ) ) {
			$code_part .= "\t\t\t\t'description' => " . self::translated_code_string( $property_description->description ) . "\n";
		}
		$code_part .= "\t\t\t]";

		return $code_part;
	}

	/**
	 * Generate the PHP code for a class property, method argument or method return type in the format expected by the underlying GraphQL engine,
	 * taking in account existing enum or array type attributes.
	 *
	 * @param ReflectionNamedType $type The reflection object representing the property, method or return type.
	 * @param object|null         $enum_type_attribute The (Arg)EnumType attribute applied to the property, method or return type, if it exists.
	 * @param object|null         $array_of_attribute The (Arg)ArrayType attribute applied to the property, method or return type, if it exists.
	 * @param string              $error_message_prefix Starting part of error messages generated by this method.
	 * @param array               $allowed_type_namespaces Allowed namespaces (Relative to the src/Api directory) for non-primitive types.
	 * @return string|null The code representation of the type, or null if there's an error.
	 */
	private static function generate_code_for_type( ReflectionNamedType $type, ?object $enum_type_attribute, ?object $array_of_attribute, string $error_message_prefix, array $allowed_type_namespaces ): ?string {
		$type_name = $type->getName();
		$is_array  = false;
		$is_enum   = false;

		if ( ! is_null( $enum_type_attribute ) ) {
			$is_enum                 = true;
			$enum_property_type_name = $enum_type_attribute->class_name;
			if ( ! str_starts_with( $enum_property_type_name, self::$base_source_namespace . 'Enums\\' ) ) {
				self::$errors[] = "$error_message_prefix has an 'EnumType' attribute declaring the type '$enum_property_type_name', which is not in the 'Enums' namespace.";
				return null;
			}
		}

		if ( ! in_array( $type_name, self::$allowed_primitive_types, true ) ) {
			if ( ! $is_enum && str_starts_with( $type_name, self::$base_source_namespace . 'Enums\\' ) ) {
				self::$errors[] = "$error_message_prefix is of type '$type_name'. Set the property type to the underlying primitive type an use the 'EnumType' attribute instead.";
				return null;
			}

			if ( ! $is_enum ) {
				$valid_type = false;
				foreach ( $allowed_type_namespaces as $allowed_type_namespace ) {
					if ( str_starts_with( $type_name, self::$base_source_namespace . $allowed_type_namespace . '\\' ) ) {
						$valid_type = true;
						break;
					}
				}

				if ( ! $valid_type ) {
					$valid_types_string = "'" . implode( "', '", $allowed_type_namespaces ) . "'";
					self::$errors[]     = "$error_message_prefix is of type '$type_name'. Only primitive types (int, float, string, bool, array) and types in the $valid_types_string namespaces are allowed.";
					return null;
				}
			}

			$is_primitive = false;
		} else {
			$is_primitive = true;
			$is_array     = $type_name === 'array';
			if ( $is_array ) {
				if ( is_null( $array_of_attribute ) ) {
					self::$errors[] = "$error_message_prefix is of type array, but it lacks the 'ArrayType' attribute.";
					return null;
				}
				$array_type_name        = $array_of_attribute->class_name;
				$array_type_is_nullable = $array_of_attribute->nullable;

				if ( ! in_array( $array_type_name, self::$allowed_primitive_types, true ) ) {
					$is_primitive = false;

					if ( ! $is_enum && str_starts_with( $array_type_name, self::$base_source_namespace . 'Enums\\' ) ) {
						self::$errors[] = "$error_message_prefix is of type array of '$array_type_name'. Set the property type to the underlying primitive type an use the 'EnumType' attribute instead.";
						return null;
					}

					if ( ! $is_enum ) {
						$valid_type = false;
						foreach ( $allowed_type_namespaces as $allowed_type_namespace ) {
							if ( str_starts_with( $array_type_name, self::$base_source_namespace . $allowed_type_namespace . '\\' ) ) {
								$valid_type = true;
								break;
							}
						}

						if ( ! $valid_type ) {
							$valid_types_string = "'" . implode( "', '", $allowed_type_namespaces ) . "'";
							self::$errors[]     = "$error_message_prefix is of type array of '$array_type_name'. Only primitive types (int, float, string, bool, array) and types in the $valid_types_string namespaces are allowed.";
							return null;
						}
					}
				}//end if

				$type_name = $array_type_name;
			}//end if
		}//end if

		if ( $is_enum ) {
			if ( ! $is_primitive ) {
				self::$errors[] = "$error_message_prefix has an 'EnumType' attribute but is of type '$type_name'. Only primitive types (int, float, string, bool, array of those) are allowed as the underlying type when 'EnumType' is present.";
				return null;
			}
			$type_name    = $enum_property_type_name;
			$is_primitive = false;
		} elseif ( $is_primitive ) {
			$type_name = preg_replace( '/^bool$/', 'boolean', $type_name );
			$type_name = "Type::$type_name()";
		}

		if ( ! $is_primitive ) {
			if ( ! class_exists( $type_name ) && ! ( str_starts_with( $type_name, self::$base_source_namespace . 'Interfaces\\' ) && trait_exists( $type_name ) ) ) {
				self::$errors[] = "$error_message_prefix is declared as being of type '$type_name', which doesn't exist.";
				return null;
			}

			$type_name = "GraphQLController::resolve_type( '" . self::class_name_without_namespace( $type_name ) . "' )";
		}

		$is_nullable = $type->allowsNull();

		if ( $is_array ) {
			if ( $is_nullable ) {
				if ( $array_type_is_nullable ) {
					$type_code = "Type::listOf($type_name)";
				} else {
					$type_code = "Type::listOf(Type::nonNull($type_name))";
				}
			} elseif ( $array_type_is_nullable ) {
					$type_code = "Type::nonNull(Type::listOf($type_name))";
			} else {
				$type_code = "Type::nonNull(Type::listOf(Type::NonNull($type_name)))";
			}
		} elseif ( $is_nullable ) {
				$type_code = $type_name;
		} else {
			$type_code = "Type::nonNull($type_name)";
		}//end if

		return $type_code;
	}

	/**
	 * Generate the GraphQL queries or mutations definition classes in the src/Internal/Api/Autogenerated/GraphQL(Queries|Mutations) directory,
	 * and also the src/Internal/Api/Autogenerated/Root(Query|Mutation)Type.php file.
	 *
	 * @param bool $generate_mutations True to process mutations, false to process queries.
	 */
	private static function generate_graphql_query_classes( bool $generate_mutations ): void {
		$operation_upper_name        = $generate_mutations ? 'Mutation' : 'Query';
		$operation_upper_plural_name = $generate_mutations ? 'Mutations' : 'Queries';
		$operation_lower_name        = strtolower( $operation_upper_name );
		$operation_lower_plural_name = strtolower( $operation_upper_plural_name );

		mkdir( self::$autogenerated_dir . '/GraphQL' . $operation_upper_plural_name );

		$class_files      = self::$source_files['Apis'];
		$used_class_names = array();
		foreach ( $class_files as $class_file ) {
			$class_name        = self::class_name_from_file_name( $class_file );
			$simple_class_name = self::class_name_without_namespace( $class_name );
			$reflection_class  = self::get_reflection_object( $class_name );
			$methods           = $reflection_class->getMethods( \ReflectionMethod::IS_PUBLIC );
			$method_entries    = array();
			foreach ( $methods as $method ) {
				$query_attribute = self::get_attribute( $method, 'Web' . $operation_upper_name );
				if ( is_null( $query_attribute ) ) {
					continue;
				}

				$method_name = $method->getName();
				$query_name  = $query_attribute->graphql_name;
				if ( isset( self::$used_graphql_query_names[ $query_name ] ) ) {
					$existing_query_class_name  = self::class_name_without_namespace( self::$used_graphql_query_names[ $query_name ][0] );
					$existing_query_method_name = self::$used_graphql_query_names[ $query_name ][1];
					self::$errors[]             = "Api type '$simple_class_name': method '$method_name' declares itself as a web query with GraphQL name '$query_name', but this name is already in use by method '$existing_query_method_name' in Api class '$existing_query_class_name'.";
				}

				$description_attribute = self::get_attribute( $method, 'Description' );
				$description           = is_null( $description_attribute ) ? $query_attribute->graphql_name . ' ' . $operation_lower_name . ' type' : $description_attribute->description;

				$enum_type_attribute = self::get_attribute( $method, 'EnumType' );
				$array_of_attribute  = self::get_attribute( $method, 'ArrayType' );

				$return_type_name = $method->getReturnType()->getName();
				if ( ( $return_type_name === 'array' || $return_type_name === '?array' ) ) {
					if ( is_null( $array_of_attribute ) ) {
						self::$errors[] = "Api type '$simple_class_name': method '$method_name': return value is of type array, but the method lacks the 'ArrayType' attribute.";
						continue;
					}
					$return_type_array_of_name = $array_of_attribute->class_name;
					if ( in_array( $return_type_array_of_name, self::$allowed_primitive_types, true ) ) {
						self::$errors[] = "Api type '$simple_class_name': method '$method_name': return value is of type array of '$return_type_array_of_name', only types in the 'ObjectTypes' namespace are allowed.";
						continue;
					}
				} elseif ( in_array( $return_type_name, self::$allowed_primitive_types, true ) ) {
					self::$errors[] = "Api type '$simple_class_name': method '$method_name': return value is of type '$return_type_name', only types in the 'ObjectTypes' namespace are allowed.";
					continue;
				}

				$type_code = self::generate_code_for_type( $method->getReturnType(), $enum_type_attribute, $array_of_attribute, "Api type '$simple_class_name': method '$method_name': return value", array( 'ObjectTypes', 'Interfaces' ) );

				$arguments                        = $method->getParameters();
				$arguments_code                   = array();
				$arguments_description_attributes = self::get_argument_attributes( $method, 'ArgDescription' );
				$arguments_array_of_attributes    = self::get_argument_attributes( $method, 'ArgArrayType' );
				$arguments_enum_type_attributes   = self::get_argument_attributes( $method, 'ArgEnumType' );
				$resolve_arguments_code           = array();
				foreach ( $arguments as $argument ) {
					$arg_name = $argument->getName();
					$arg_type = $argument->getType();

					if ( $arg_name === '_fields_info' ) {
						if ( $arg_type->getName() !== 'array' || ! $arg_type->allowsNull() ) {
							self::$errors[] = "Api class '$simple_class_name': method '$method_name': argument '_fields_info' must be of type '?array'";
							continue;
						}
						$resolve_arguments_code[] = 'GraphQLController::get_fields_info( $info )';
					} else {
						$array_of_attribute  = self::get_attribute( $argument, 'ArrayType' ) ?? $arguments_array_of_attributes[ $arg_name ] ?? null;
						$enum_type_attribute = self::get_attribute( $argument, 'EnumType' ) ?? $arguments_enum_type_attributes[ $arg_name ] ?? null;
						$arg_type_code       = self::generate_code_for_type( $arg_type, $enum_type_attribute, $array_of_attribute, "Api class '$simple_class_name': method '$method_name': argument '$arg_name'", array( 'InputTypes' ) );
						if ( is_null( $arg_type_code ) ) {
							continue;
						}

						$description_attribute    = self::get_attribute( $argument, 'Description' ) ?? $arguments_description_attributes[ $arg_name ] ?? null;
						$arg_description          = is_null( $description_attribute ) ? '' : "\t'description' => " . self::translated_code_string( $description_attribute->description ) . ",\n\t\t\t\t\t";
						$arguments_code[]         = "\n\t\t\t\t\t" . self::code_string( $argument->getName() ) . " => [\n\t\t\t\t\t$arg_description\t'type' => $arg_type_code\n\t\t\t\t\t]";
						$resolve_arguments_code[] = $argument->allowsNull() ? "\$args['$arg_name'] ?? null" : "\$args['$arg_name']";
					}
				}//end foreach

				$resolve_arguments_all_code = implode( ', ', $resolve_arguments_code );
				$method_entries[]           = "\t\t\t'$query_name' => [\n\t\t\t\t'type' => $type_code,\n\t\t\t\t'description' => " . self::translated_code_string( $description ) . ",\n\t\t\t\t'args' =>[" . implode( ",\t\t\t\t\t", $arguments_code ) . "\n\t\t\t\t],\n\t\t\t\t'resolve'=> fn( \$object_value, array \$args, \$context, ResolveInfo \$info) => \$container->get( $simple_class_name::class )->$method_name($resolve_arguments_all_code)\n\t\t\t]";

				$method_data = array(
					'method'          => $method,
					'class_name'      => $class_name,
					'query_attribute' => $query_attribute,
				);

				if ( $generate_mutations ) {
					self::$mutation_methods[ $query_name ] = $method_data;
				} else {
					self::$query_methods[ $query_name ] = $method_data;
				}

				self::$used_graphql_query_names[ $query_name ] = array( $class_name, $method_name );
			}//end foreach

			if ( empty( $method_entries ) ) {
				continue;
			}

			$used_class_names[] = "\t\t\tGraphQL" . $operation_upper_plural_name . '\\' . $simple_class_name . $operation_upper_plural_name . '::get_' . $operation_lower_plural_name . '()';

			self::generate_file(
				'ClassGraphQLQueries',
				array(
					'CLASS_NAME'             => $simple_class_name . $operation_upper_plural_name,
					'API_CLASS_SIMPLE_NAME'  => $simple_class_name,
					'API_CLASS_NAME'         => $class_name,
					'QUERIES'                => implode( ",\n", $method_entries ),
					'OPERATION_LOWER_PLURAL' => $operation_lower_plural_name,
					'OPERATION_UPPER_PLURAL' => $operation_upper_plural_name,
				),
				'GraphQL' . $operation_upper_plural_name . '/' . $simple_class_name . $operation_upper_plural_name
			);
		}//end foreach

		if ( empty( $used_class_names ) ) {
			return;
		}

		self::generate_file(
			'RootGraphQLType',
			array(
				'CLASS_NAME'      => 'Root' . $operation_upper_name . 'Type',
				'OPERATION_UPPER' => $operation_upper_name,
				'OPERATION_LOWER' => $operation_lower_name,
				'QUERIES'         => implode( ",\n", $used_class_names ),
			),
			'Root' . $operation_upper_name . 'Type'
		);
	}

	/**
	 * Generate the REST controller classes inside the src/Internal/Api/Autogenerated/RestControllers directory,
	 * and also the src/Internal/Api/Autogenerated/RestControllersServiceProvider.php file.
	 *
	 * TODO: There's room for deduplication here as this code copies a lot from generate_graphql_query_classes.
	 */
	private static function generate_rest_controller_classes(): void {
		mkdir( self::$autogenerated_dir . '/RestControllers' );

		$class_files      = self::$source_files['Apis'];
		$used_class_names = array();
		foreach ( $class_files as $class_file ) {
			$class_name         = self::class_name_from_file_name( $class_file );
			$simple_class_name  = self::class_name_without_namespace( $class_name );
			$reflection_class   = self::get_reflection_object( $class_name );
			$methods            = $reflection_class->getMethods( \ReflectionMethod::IS_PUBLIC );
			$method_entries     = array();
			$run_method_entries = array();
			foreach ( $methods as $method ) {
				$is_mutation     = false;
				$query_attribute = self::get_attribute( $method, 'WebQuery' );
				if ( is_null( $query_attribute ) ) {
					$query_attribute = self::get_attribute( $method, 'WebMutation' );
					if ( is_null( $query_attribute ) ) {
						continue;
					}
					$is_mutation = true;
				}

				$method_name = $method->getName();
				$query_name  = self::get_rest_name( $query_attribute );

				if ( isset( self::$used_rest_query_names[ $query_name ] ) ) {
					$existing_query_class_name  = self::class_name_without_namespace( self::$used_rest_query_names[ $query_name ][0] );
					$existing_query_method_name = self::$used_rest_query_names[ $query_name ][1];
					self::$errors[]             = "Api type '$simple_class_name': method '$method_name' declares itself as a web query with REST name '$query_name', but this name is already in use by method '$existing_query_method_name' in Api class '$existing_query_class_name'.";
				}

				$description_attribute = self::get_attribute( $method, 'Description' );
				$description           = is_null( $description_attribute ) ? $query_name . ( $is_mutation ? ' mutation' : ' query' ) . ' REST endpoint.' : $description_attribute->description;

				// TODO: Schema.

				$arguments                        = $method->getParameters();
				$arguments_code                   = array();
				$arguments_use_code               = array();
				$arguments_description_attributes = self::get_argument_attributes( $method, 'ArgDescription' );
				$arguments_array_of_attributes    = self::get_argument_attributes( $method, 'ArgArrayType' );
				$arguments_enum_type_attributes   = self::get_argument_attributes( $method, 'ArgEnumType' );
				foreach ( $arguments as $argument ) {
					$arg_name = $argument->getName();
					$arg_type = $argument->getType();

					if ( $arg_name === '_fields_info' ) {
						if ( $arg_type->getName() !== 'array' || ! $arg_type->allowsNull() ) {
							self::$errors[] = "Api class '$simple_class_name': method '$method_name': argument '_fields_info' must be of type '?array'";
							continue;
						}
						$is_array      = false;
						$is_object     = false;
						$is_nullable   = true;
						$arg_type_code = 'object';
					} else {
						$array_of_attribute  = self::get_attribute( $argument, 'ArrayType' ) ?? $arguments_array_of_attributes[ $arg_name ] ?? null;
						$enum_type_attribute = self::get_attribute( $argument, 'EnumType' ) ?? $arguments_enum_type_attributes[ $arg_name ] ?? null;
						$arg_type_code       = self::generate_code_for_type( $arg_type, $enum_type_attribute, $array_of_attribute, "Api class '$simple_class_name': method '$method_name': argument '$arg_name'", array( 'InputTypes' ) );
						if ( is_null( $arg_type_code ) ) {
							continue;
						}

						$arg_type_name = $arg_type->getName();
						$is_nullable   = $argument->allowsNull();
						$is_array      = $arg_type_name === 'array';
						if ( $is_array ) {
							$array_of_class_name = $array_of_attribute->class_name;
						}
						$is_object     = ! $is_array && ! isset( self::$primitive_type_to_rest_type[ $arg_type_name ] );
						$arg_type_code = $is_object ? 'object' : self::$primitive_type_to_rest_type[ $arg_type_name ];
					}//end if

					$description_attribute = self::get_attribute( $argument, 'Description' ) ?? $arguments_description_attributes[ $arg_name ] ?? null;
					$arg_description       = is_null( $description_attribute ) ? '' : "\t\t\t\t'description' => " . self::translated_code_string( $description_attribute->description ) . ",\n\t\t\t\t\t";

					$arguments_code[] =
						"\n\t\t\t\t\t\t" . self::code_string( $argument->getName() ) . " => [\n\t\t\t$arg_description\t\t'type' => '$arg_type_code',\n" .
						"\t\t\t\t\t\t\t'context' => array('view', 'edit'),\n" .
						"\t\t\t\t\t\t\t'readonly' => true,\n" .
						"\t\t\t\t\t\t\t'required' => " . ( $is_nullable ? 'false' : 'true' ) . ",\n" .
						( $is_array ? "\t\t\t\t\t\t\t\t'items' => ['type' => ' " . $array_of_class_name . "']\n" : '' ) .
						( $is_object ? "\t\t\t\t\t\t// TODO: Object properties.\n" : '' ) .
						"\t\t\t\t\t\t\t]";
					// TODO: object properties.

					if ( $is_array && ! isset( self::$primitive_type_to_rest_type[ $array_of_attribute->class_name ] ) ) {
						$input_type_class_name = self::class_name_without_namespace( $array_of_attribute->class_name );
						$arguments_use_code[]  = "array_map(fn(\$item) => GraphQLController::resolve_type('${input_type_class_name}')->parseValue( \$item ), \$request['$arg_name'] )";
					} elseif ( $is_object ) {
						$input_type_class_name = self::class_name_without_namespace( $arg_type_name );
						$arguments_use_code[]  = "GraphQLController::resolve_type('${input_type_class_name}')->parseValue( \$request['$arg_name'] )";
					} else {
						$arguments_use_code[] = "\$request['$arg_name']";
					}
				}//end foreach

				$method_entries[] =
					"\t\tregister_rest_route(\n" .
					"\t\t\t\$this->route_namespace,\n" .
					"\t\t\t'/$query_name',\n" .
					"\t\t\tarray(\n" .
					"\t\t\t\tarray(\n" .
					"\t\t\t\t\t'methods' => \\WP_REST_Server::" . ( $is_mutation ? 'CREATABLE' : 'READABLE' ) . ",\n" .
					"\t\t\t\t\t'description' => " . self::translated_code_string( $description ) . ",\n" .
					"\t\t\t\t\t'callback' => fn( \$request ) => \$this->run( \$request, 'run_" . $method_name . "' ),\n" .
					"\t\t\t\t\t'permission_callback' => '__return_true',\n" .
					"\t\t\t\t\t'args' => array(" .
					implode( ",\t\t\t\t\t\t", $arguments_code ) .
					"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);";

				$args_use_code_imploded = implode( ', ', $arguments_use_code );
				$run_method_entries[]   =
					"\tpublic function run_$method_name( \\WP_REST_Request \$request ) {\n" .
					"\t\treturn wc_get_container()->get( $simple_class_name::class )->$method_name($args_use_code_imploded);\n" .
					"\t}\n";

				self::$used_rest_query_names[ $query_name ] = array( $class_name, $method_name );
			}//end foreach

			if ( empty( $method_entries ) ) {
				continue;
			}

			self::generate_file(
				'ClassRestController',
				array(
					'CLASS_NAME'          => $class_name,
					'SIMPLE_CLASS_NAME'   => $simple_class_name,
					'ROUTE_REGISTRATIONS' => implode( "\n\n", $method_entries ),
					'RUN_METHODS'         => implode( "\n", $run_method_entries ),
				),
				'RestControllers/' . $simple_class_name . 'Controller'
			);

			$used_class_names[] = '\\' . self::$base_autogenerated_namespace . 'RestControllers\\' . $simple_class_name . 'Controller::class';
		}//end foreach

		if ( empty( $used_class_names ) ) {
			return;
		}

		self::generate_file( 'RestControllersServiceProvider', array( 'CLASS_NAMES' => implode( ",\n\t\t", $used_class_names ) ) );
	}

	/**
	 * Get the REST name for a given query or mutation.
	 *
	 * @param object $query_attribute The WebQuery or WebMutation attribute defining the operation.
	 * @return string The explicit or automatically generated (converting PascalCase to camel_case) REST name for the operation.
	 */
	private static function get_rest_name( object $query_attribute ): string {
		return $query_attribute->rest_name ?? strtolower( preg_replace( '/(?<!^)[A-Z]/', '_$0', $query_attribute->graphql_name ) );
	}

	/**
	 * Get the existing instances of argument related attributes applied to a method.
	 *
	 * @param ReflectionMethod $method The method to scan.
	 * @param string           $attribute_name The class name of the attribute to search for, without namespace and without the 'Attribute' suffix.
	 * @return array An array of argument name => attribute instance.
	 */
	private static function get_argument_attributes( ReflectionMethod $method, string $attribute_name ): array {
		$attribute_name     = self::$base_internal_namespace . 'DesignTime\\Attributes\\' . $attribute_name . 'Attribute';
		$all_attributes     = $method->getAttributes();
		$attributes_of_type = array_filter( $all_attributes, fn( $attribute ) => $attribute->getName() === $attribute_name );
		$result             = array();
		$warned             = false;
		foreach ( $attributes_of_type as $attribute ) {
			$attribute_instance = $attribute->newInstance();
			$arg_name           = $attribute->newInstance()->arg_name;
			if ( ! $warned && isset( $result[ $arg_name ] ) ) {
				$class_name       = self::class_name_without_namespace( $method->getDeclaringClass()->getName() );
				$method_name      = $method->getName();
				self::$warnings[] = "Api class '$class_name': method '$method_name' has multiple instances of attribute '$attribute_name', only one will be used.";
				$warned           = true;
			}
			$result[ $arg_name ] = $attribute_instance;
		}
		return $result;
	}

	/**
	 * Get a reflection object for a given class, using a cache.
	 *
	 * @param string $class_name The name of the class to get the reflection object for.
	 * @return ReflectionClass The obtained reflection class.
	 */
	private static function get_reflection_object( string $class_name ): ReflectionClass {
		if ( ! isset( self::$reflection_classes_cache[ $class_name ] ) ) {
			self::$reflection_classes_cache[ $class_name ] = new ReflectionClass( $class_name );
		}
		return self::$reflection_classes_cache[ $class_name ];
	}

	/**
	 * Get an instance of an attribute applied to a class, method, method argument or class constant.
	 *
	 * @param object $item The reflection object representing the item with the attribute.
	 * @param string $name The class name of the attribute to search for, without namespace and without the 'Attribute' suffix.
	 * @return object|null Attribute instance, or null if the item doesn't have the specified attribute applied.
	 */
	private static function get_attribute( object $item, string $name ): ?object {
		$name               = self::$base_internal_namespace . 'DesignTime\\Attributes\\' . $name . 'Attribute';
		$all_attributes     = $item->getAttributes();
		$attributes_of_type = array_filter( $all_attributes, fn( $attribute ) => $attribute->getName() === $name );
		return empty( $attributes_of_type ) ? null : current( $attributes_of_type )->newInstance();

		// TODO: Why the following doesn't work??
		// $attributes = $item->getAttributes( self::$base_internal_namespace . 'DesignTime\\Attributes\\' . $name . '\\Attribute');
		// return empty($attributes) ? null : current($attributes)->newInstance();.
	}

	/**
	 * Generate a file from a template and a set of placeholders to be replaced.
	 * Placeholders are expected to be in the form {{NAME}}.
	 *
	 * @param string      $template_name Name of the template file, without path and without the .template extension.
	 * @param array       $replacements Associative array of replacement name => remplacement contents.
	 * @param string|null $target_file_name Target file name relative to the src/Internal/Api/Autogenerated directory, null to use the template name.
	 */
	private static function generate_file( string $template_name, array $replacements, string $target_file_name = null ): void {
		$target_file_name ??= $template_name;
		$template_contents = file_get_contents( self::$templates_dir . '/' . $template_name . '.template' );
		foreach ( $replacements as $key => $value ) {
			$template_contents = str_replace( '{{' . $key . '}}', $value, $template_contents );
		}

		$template_contents = trim( $template_contents ) . "\n\n// Autogenerated file, don't modify manually!\n";

		stream_wrapper_unregister( UseStatementsInjector::PROTOCOL );
		stream_wrapper_restore( UseStatementsInjector::PROTOCOL );
		file_put_contents( self::$autogenerated_dir . '/' . $target_file_name . '.php', $template_contents );
		stream_wrapper_unregister( UseStatementsInjector::PROTOCOL );
		stream_wrapper_register( UseStatementsInjector::PROTOCOL, UseStatementsInjector::class );
	}

	/**
	 * Recursive directory contents deletion.
	 *
	 * @param string $dir Path of the directory to delete.
	 * @param bool   $remove_dir_itself True to delete the directory itself too once it's empty.
	 */
	private static function recursive_rmdir( string $dir, bool $remove_dir_itself ): void {
		$objects = scandir( $dir );
		foreach ( $objects as $object ) {
			if ( $object !== '.' && $object !== '..' ) {
				if ( is_dir( $dir . '/' . $object ) && ! is_link( $dir . '/' . $object ) ) {
					self::recursive_rmdir( $dir . '/' . $object, true );
				} else {
					unlink( $dir . '/' . $object );
				}
			}
		}

		if ( $remove_dir_itself ) {
			rmdir( $dir );
		}
	}

	/**
	 * Optionally recursive file search.
	 *
	 * @param string $directory Directory where files are to be searched.
	 * @param bool   $recursive True to search files recursively in subdirectories too.
	 * @return array Full paths of all the files found.
	 */
	private static function file_search( string $directory, bool $recursive = true ): array {
		$directory = rtrim( $directory, '/' );
		$files     = glob( $directory . '/*.php' );
		if ( $recursive ) {
			$dirs = glob( $directory . '/*', GLOB_ONLYDIR );
			foreach ( $dirs as $dir ) {
				if ( is_dir( $dir ) ) {
					$files = array_merge( $files, self::file_search( $dir, '*.php' ) );
				}
			}
		}

		return array_map( 'realpath', $files );
	}

	/**
	 * Get the class name from a file name.
	 *
	 * @param string $file_name The file name.
	 * @return string The class name.
	 */
	private static function class_name_from_file_name( string $file_name ): string {
		if ( str_starts_with( $file_name, self::$base_source_dir ) ) {
			$base_dir       = self::$base_source_dir;
			$base_namespace = self::$base_source_namespace;
		} else {
			$base_dir       = self::$base_internal_dir;
			$base_namespace = self::$base_internal_namespace;
		}

		$file_name  = ltrim( str_replace( $base_dir, '', $file_name ), '/' );
		$class_name = $base_namespace . str_replace( '/', '\\', $file_name );
		return '\\' . str_replace( '.php', '', $class_name );
	}

	/**
	 * Given a full class name, return the simple class name (without the namespace).
	 *
	 * @param string $class_name Full namespaced class name.
	 * @return string Class name without the namespace.
	 */
	private static function class_name_without_namespace( string $class_name ): string {
		// A '?:' would convert this to a one-liner, but WP coding standards disallow these :shrug:.
		$result = substr( strrchr( $class_name, '\\' ), 1 );
		return $result ? $result : $class_name;
	}

	/**
	 * Convert a string to its representation in PHP code.
	 *
	 * @param string $string The string.
	 * @return string The PHP representation of the string.
	 */
	private static function code_string( string $string ): string {
		return '"' . addcslashes( $string, "\n\t\\'\"" ) . '"';
	}

	/**
	 * Convert a string to its representation in PHP code, wrapped in the '__' function.
	 *
	 * @param string $string The string.
	 * @return string The PHP representation of the translated string.
	 */
	private static function translated_code_string( string $string ): string {
		return '__( ' . self::code_string( $string ) . ", 'woocommerce' )";
	}

	/**
	 * Generate the API documentation in src/api (in the root of the repository).
	 */
	private static function generate_documentation(): void {
		echo "Generating documentation...\n";

		self::$base_docs_dir = realpath( self::$base_source_dir . '/../../../../docs' );
		if ( is_dir( self::$base_docs_dir . '/api' ) ) {
			self::recursive_rmdir( self::$base_docs_dir . '/api', false );
		} else {
			mkdir( self::$base_docs_dir . '/api' );
		}
		self::$base_docs_dir .= '/api';

		mkdir( self::$base_docs_dir . '/Enums' );

		foreach ( self::$source_files['Enums'] as $file ) {
			self::generate_doc_for_enum_type( self::class_name_from_file_name( $file ) );
		}

		mkdir( self::$base_docs_dir . '/Interfaces' );

		foreach ( self::$source_files['Interfaces'] as $file ) {
			self::generate_doc_for_type( self::class_name_from_file_name( $file ), 'Interfaces' );
		}

		mkdir( self::$base_docs_dir . '/InputTypes' );

		foreach ( self::$source_files['InputTypes'] as $file ) {
			self::generate_doc_for_type( self::class_name_from_file_name( $file ), 'InputTypes' );
		}

		mkdir( self::$base_docs_dir . '/ObjectTypes' );

		foreach ( self::$source_files['ObjectTypes'] as $file ) {
			self::generate_doc_for_type( self::class_name_from_file_name( $file ), 'ObjectTypes', true );
		}

		mkdir( self::$base_docs_dir . '/Queries' );

		foreach ( self::$query_methods as $query_name => $method_data ) {
			self::generate_doc_for_query( $query_name, $method_data, false );
		}

		mkdir( self::$base_docs_dir . '/Mutations' );

		foreach ( self::$mutation_methods as $mutation_name => $method_data ) {
			self::generate_doc_for_query( $mutation_name, $method_data, true );
		}

		$reference_doc_contents = "# WooCommerce API Reference\n\n";
		foreach ( self::$api_dirs_and_names as $dir_name => $print_name ) {
			$reference_doc_contents .= "## $print_name\n\n";
			$docs_files              = glob( self::$base_docs_dir . '/' . $dir_name . '/*.md' );
			usort( $docs_files, fn( $x, $y ) => $x <=> $y );
			foreach ( $docs_files as $doc_file_name ) {
				$doc_file_name           = pathinfo( $doc_file_name, PATHINFO_FILENAME );
				$reference_doc_contents .= "* [$doc_file_name]($dir_name/${doc_file_name}.md)\n";
			}
			$reference_doc_contents .= "\n";
		}

		$file_path = self::$base_docs_dir . '/Reference.md';
		file_put_contents( $file_path, $reference_doc_contents );
	}

	/**
	 * Generate the API documentation for an enum type.
	 *
	 * @param string $class_name The full class name of the enum type.
	 */
	private static function generate_doc_for_enum_type( string $class_name ): void {
		$simple_class_name = self::class_name_without_namespace( $class_name );

		$reflection_class      = self::get_reflection_object( $class_name );
		$description_attribute = self::get_attribute( $reflection_class, 'Description' );
		$description           = is_null( $description_attribute ) ? '(No description)' : $description_attribute->description;

		$file_contents = "# ${simple_class_name}\n\n${description}\n\n## Values for `${simple_class_name}`\n| Name | Value | Description |\n|-|-|-|\n";

		$constants = $reflection_class->getConstants();
		foreach ( $constants as $constant_name => $constant_value ) {
			$reflection_constant = new \ReflectionClassConstant( $class_name, $constant_name );
			if ( ! $reflection_constant->isPublic() ) {
				continue;
			}
			$constant_description_attribute = self::get_attribute( $reflection_constant, 'Description' );
			$constant_description           = is_null( $constant_description_attribute ) ? '' : $constant_description_attribute->description;

			if ( is_string( $constant_value ) ) {
				$constant_value = "'$constant_value'";
			}

			$file_contents .= "**$constant_name** | `$constant_value` | $constant_description\n";
		}

		$file_path = self::$base_docs_dir . "/Enums/${simple_class_name}.md";
		file_put_contents( $file_path, $file_contents );
	}

	/**
	 * Generate the API documentation for an input/object/interface type.
	 *
	 * @param string $class_name The full class name of the type.
	 * @param string $docs_dir_name Destination directory for the generated file.
	 * @param bool   $include_interfaces True to include information about implemented interfaces.
	 */
	private static function generate_doc_for_type( string $class_name, string $docs_dir_name, bool $include_interfaces = false ): void {
		$simple_class_name = self::class_name_without_namespace( $class_name );

		$reflection_class      = self::get_reflection_object( $class_name );
		$description_attribute = self::get_attribute( $reflection_class, 'Description' );
		$description           = is_null( $description_attribute ) ? '(No description)' : $description_attribute->description;

		$interfaces_info = '';
		if ( $include_interfaces ) {
			$reflection_class       = self::get_reflection_object( $class_name );
			$implemented_interfaces = $reflection_class->getTraits();
			if ( empty( $implemented_interfaces ) ) {
				// phpcs:ignore Generic.PHP.DiscourageGoto.Found
				goto NoInterfaces;
			}

			$interfaces_info = "## Implemented interfaces\n\n";

			foreach ( $implemented_interfaces as $implemented_interface ) {
				$interface_name   = self::class_name_without_namespace( $implemented_interface->getName() );
				$interfaces_info .= "* [$interface_name](../Interfaces/$interface_name.md)\n";
			}

			$interfaces_info .= "\n";
		}
		// phpcs:ignore Generic.PHP.DiscourageGoto.Found
		NoInterfaces:

		$file_contents = "# ${simple_class_name}\n\n${description}\n\n$interfaces_info## Fields for `${simple_class_name}`\n| Name | Type | Description |\n|-|-|-|\n";

		$properties = $reflection_class->getProperties();
		foreach ( $properties as $property ) {
			if ( ! $property->isPublic() ) {
				continue;
			}

			$property_name                  = $property->getName();
			$property_type_doc_name         = self::generate_type_representation_for_doc( $property );
			$property_description_attribute = self::get_attribute( $property, 'Description' );
			$property_description           = is_null( $property_description_attribute ) ? '' : $property_description_attribute->description;

			$file_contents .= "$property_name | $property_type_doc_name | $property_description\n";
		}

		$file_path = self::$base_docs_dir . "/$docs_dir_name/${simple_class_name}.md";
		file_put_contents( $file_path, $file_contents );
	}

	/**
	 * Generate the representation of a type in GraphQL notation (with "[]" for arrays and "!" for non-nullable items),
	 * including a link to the doc for the type for non-primitive types.
	 *
	 * @param object                   $typed_item The item (class property, method argument, method -for the return type-) that has the type assigned.
	 * @param ReflectionNamedType|null $item_type The type to get the representation for, if null it will be taken from $typed_item.
	 * @return string The representation of the type in GraphQL notation.
	 */
	private static function generate_type_representation_for_doc( object $typed_item, ?ReflectionNamedType $item_type = null ): string {
		$item_type    ??= $typed_item->getType();
		$item_type_name = $item_type->getName();

		$enum_type_attribute  = self::get_attribute( $typed_item, 'EnumType' );
		$array_type_attribute = self::get_attribute( $typed_item, 'ArrayType' );

		if ( is_null( $array_type_attribute ) ) {
			$effective_item_type_name = is_null( $enum_type_attribute ) ? $item_type_name : $enum_type_attribute->class_name;
			$item_type_doc_name       = self::class_name_without_namespace( $effective_item_type_name );
		} else {
			$effective_item_type_name = is_null( $enum_type_attribute ) ? $array_type_attribute->class_name : $enum_type_attribute->class_name;
			$maybe_bang               = $array_type_attribute->nullable ? '' : '!';
			$item_type_doc_name       = '[' . self::class_name_without_namespace( $effective_item_type_name ) . "$maybe_bang]";
		}
		if ( ! $item_type->allowsNull() ) {
			$item_type_doc_name .= '!';
		}

		$effective_item_type_name_parts = explode( '\\', $effective_item_type_name );
		if ( count( $effective_item_type_name_parts ) === 1 ) {
			$item_type_doc_name = "`$item_type_doc_name`";
		} else {
			end( $effective_item_type_name_parts );
			$subdirectory          = prev( $effective_item_type_name_parts );
			$simple_item_type_name = self::class_name_without_namespace( $effective_item_type_name );
			$item_type_doc_name    = "[`$item_type_doc_name`](../$subdirectory/$simple_item_type_name.md)";
		}

		return $item_type_doc_name;
	}

	/**
	 * Generate the API documentation for a query or mutation.
	 *
	 * @param string $query_name Query or mutation GraphQL name.
	 * @param array  $method_data Metadata about the query method, as gathered during the API generation.
	 * @param bool   $is_mutation True if the operation is a mutation, false if it's a query.
	 */
	private static function generate_doc_for_query( string $query_name, array $method_data, bool $is_mutation ): void {
		$method            = $method_data['method'];
		$query_attribute   = $method_data['query_attribute'];
		$query_name        = $query_attribute->graphql_name;
		$query_name_suffix = $is_mutation ? 'mutation' : 'query';
		$rest_name         = self::get_rest_name( $query_attribute );
		$class_name        = $method_data['class_name'];
		$method_name       = $method->getName();
		$rest_verb         = $is_mutation ? 'POST' : 'GET';

		$return_type     = $method->getReturnType();
		$return_type_doc = self::generate_type_representation_for_doc( $method, $return_type );

		$description_attribute = self::get_attribute( $method, 'Description' );
		$description           = is_null( $description_attribute ) ? '(No description)' : $description_attribute->description;

		$file_contents = "# $query_name $query_name_suffix\n\n$description\n\n### Code method\n`${class_name}::${method_name}`\n\n### REST route\n`$rest_verb /wp-json/wc/v4/rest/$rest_name`\n\n## Return type\n$return_type_doc\n\n## Arguments\n\n";

		$arguments = array_filter( $method->getParameters(), fn( $argument ) => $argument->getName() !== '_fields_info' );
		usort( $arguments, fn( $x, $y ) => $x->getName() <=> $y->getName() );

		if ( empty( $arguments ) ) {
			$file_contents .= 'None';
		} else {
			$file_contents .= "| Name | Type | Description |\n|-|-|-|\n";
			foreach ( $arguments as $argument ) {
				$argument_name                  = $argument->getName();
				$argument_type_doc_name         = self::generate_type_representation_for_doc( $argument );
				$argument_description_attribute = self::get_attribute( $argument, 'Description' );
				$argument_description           = is_null( $argument_description_attribute ) ? '' : $argument_description_attribute->description;
				if ( $argument_description === '' && $argument_name === 'input' ) {
					$argument_description = 'Input data for the ' . ( $is_mutation ? 'mutation' : 'query' );
				}

				$file_contents .= "$argument_name | $argument_type_doc_name | $argument_description\n";
			}
		}

		$dir_name  = $is_mutation ? 'Mutations' : 'Queries';
		$file_path = self::$base_docs_dir . "/$dir_name/${query_name}.md";
		file_put_contents( $file_path, $file_contents );
	}

	/**
	 * Minimalistic class autoloader for the script.
	 *
	 * @param string $class_name The name of the class to load.
	 */
	private static function load_class( string $class_name ): void {
		self::include_if_exists( $class_name, self::$base_internal_namespace, self::$base_internal_dir ) ||
		self::include_if_exists( $class_name, self::$base_source_namespace, self::$base_source_dir );
	}

	/**
	 * Given a class name, load (with 'require_once') it if it exists.
	 *
	 * @param string $class_name Name of the class.
	 * @param string $base_namespace Allowed base namespace for the class.
	 * @param string $base_dir_for_namespace Expected base directory for the class.
	 * @return bool True if the class file has been found and included, false otherwise.
	 */
	private static function include_if_exists( string $class_name, string $base_namespace, string $base_dir_for_namespace ): bool {
		if ( ! str_starts_with( $class_name, $base_namespace ) ) {
			return false;
		}

		$relative_class_name = str_replace( $base_namespace, '', $class_name );
		$file_path           = realpath( $base_dir_for_namespace ) . '/' . $relative_class_name;
		$file_path           = str_replace( '\\', '/', $file_path ) . '.php';
		if ( is_file( $file_path ) ) {
			require_once $file_path;
			return true;
		}

		return false;
	}
}

ApiBuilder::run();

// phpcs:enable WordPress.WP.AlternativeFunctions, WordPress.Security.EscapeOutput.OutputNotEscaped, WordPress.PHP.YodaConditions.NotYoda
